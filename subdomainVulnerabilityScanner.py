import dns.resolver
import pandas as pd

class SubdomainVulnerabilityScanner:
    def __init__(self):
        self.resultsDataframe = pd.DataFrame(columns=['FQDN', 'target_domain', 'vulnerable' , 'takeover_type', 'vulnerability_notes'])


    def check_vulnerability(self, df, record_type, takeover_type_name, vulnerability_note, check_func):
        filtered_df = df.loc[df['record_type'] == record_type]

        for index, row in filtered_df.iterrows():
            fqdn = row["FQDN"]
            record_result = row["record_result"]
            is_vulnerable = check_func(record_result, fqdn)

            takeover_type = takeover_type_name
            vulnerability_notes = vulnerability_note if is_vulnerable else 'safe'

            new_row = pd.DataFrame({'FQDN': [fqdn], 'target_domain': [record_result], 'vulnerable': [is_vulnerable], 'takeover_type': [takeover_type], 'vulnerability_notes': [vulnerability_notes]})
            self.resultsDataframe = pd.concat([self.resultsDataframe, new_row], ignore_index=True)

    def retrieveResults(self):
        return self.resultsDataframe

    def cnameVulnerabilityCheck(self, subdomainDataframe):
        self.check_vulnerability(subdomainDataframe, 'cname_record', "CNAME", "Dead or inactive service", self.is_vulnerable_DNS_check);


    def nsVulnerabilityCheck(self, subdomainDataframe):
        self.check_vulnerability(subdomainDataframe, 'ns_record', "NS", "Vulnerable name server", self.is_vulnerable_name_server);

    def createReport(self, outputFileName, fileType):
        # Check if the resultsDataframe is empty
        if self.resultsDataframe.empty:
            print("No data to create a report from.")
            return

        # Define the file type-specific code inside the match statement
        reportdir = "reports"
        match fileType:
            case 'csv':
                self.resultsDataframe.to_csv(f"{reportdir}/{outputFileName}.csv", index=False)
            case 'excel':
                self.resultsDataframe.to_excel(f"{reportdir}/{outputFileName}.xlsx", index=False)
            case 'html':
                self.resultsDataframe.to_html(f"{reportdir}/{outputFileName}.html", index=False)
            case 'json':
                self.resultsDataframe.to_json(f"{reportdir}/{outputFileName}.json", orient="records")
            case 'pickle':
                self.resultsDataframe.to_pickle(f"{reportdir}/{outputFileName}.pkl")
            case 'parquet':
                self.resultsDataframe.to_parquet(f"{reportdir}/{outputFileName}.parquet", index=False)
            case 'feather':
                self.resultsDataframe.to_feather(f"{reportdir}/{outputFileName}.feather")
            case 'tex':
                self.resultsDataframe.to_latex(f"{reportdir}/{outputFileName}.tex")
            case _:
                print(f"Unsupported file type: {fileType}.")



    def is_vulnerable_DNS_check(self, domain, fqdn):
        try:
            dns.resolver.query(domain, "A")
            return False  # Not vulnerable
        except dns.resolver.NXDOMAIN:
            return True  # Vulnerable
        except dns.exception.DNSException as e:
            return False  # Not vulnerable
        
        
    def is_vulnerable_name_server(self, ns_server, domain):
        try:
            # Resolve the A record for the domain
            answers = dns.resolver.query(domain, 'A')
            # Return the IP address
            ns_server_ip =  answers[0].address
            
            if ns_server_ip:
                # Create a resolver and specify the name server IP to use
                resolver = dns.resolver.Resolver(configure=False)
                resolver.nameservers = [ns_server_ip]
                
                # Query the A record for the target domain
                answers = resolver.query(domain, 'A')            
                # Successfully used NS, thus not vulnerable
                return False
            else:
                # Name server IP resolution failed, consider it vulnerable
                return True

        except dns.resolver.NXDOMAIN:
            return True  # Vulnerable (NXDOMAIN)
        except dns.resolver.YXDOMAIN:
            return True  # Vulnerable (YXDOMAIN)
        except dns.exception.DNSException as e:
            return False  # Not vulnerable

